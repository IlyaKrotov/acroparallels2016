        -:    0:Source:__mapped_file.c
        -:    0:Graph:__mapped_file.gcno
        -:    0:Data:__mapped_file.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <sys/types.h>
        -:    2:#include <sys/stat.h>
        -:    3:#include <fcntl.h>
        -:    4:#include <sys/mman.h>
        -:    5:#include <stddef.h>
        -:    6:#include <string.h>
        -:    7:#include <unistd.h>
        -:    8:
        -:    9:#include "chunk_manager.h"
        -:   10:#include "mfdef.h"
        -:   11:#include "mf_iterator.h"
        -:   12:#include "log.h"
        -:   13:#include "mapped_file.h"
        -:   14:
        1:   15:int __mf_open(const char* name, size_t max_memory, int flags, int perms, mf_handle_t* mf) {
        1:   16:	if(name == NULL || mf == NULL)
    #####:   17:		return EINVAL;
        -:   18:
        -:   19:	//flags &= !O_CREAT;
        1:   20:	int fd = open(name, flags, perms);
        1:   21:	if(fd == -1) return errno;
        -:   22:
        1:   23:	chpool_t *cpool = NULL;
        -:   24:
        1:   25:	int prot = (flags & O_RDWR) ? PROT_READ | PROT_WRITE : (flags & O_RDONLY) ? PROT_READ : PROT_WRITE;
        1:   26:	int err = chpool_construct(max_memory, fd, prot, &cpool);
        1:   27:	if(err) return err;
        -:   28:
        1:   29:	*mf = (void *)cpool;
        1:   30:	return 0;
        -:   31:}
        -:   32:
        1:   33:int __mf_close(mf_handle_t mf) {
        1:   34:	if(!mf) return EAGAIN;
        1:   35:	return chpool_destruct((chpool_t **)&mf); 
        -:   36:}
        -:   37:
        2:   38:int __mf_read(mf_handle_t mf, off_t offset, size_t size, ssize_t *read_bytes, void* buf) {
        2:   39:	chpool_t *cpool = (chpool_t *)mf;
        2:   40:	*read_bytes = 0;
        2:   41:	log_write(LOG_INFO, "__mf_read: start reading from file...\n");
        -:   42:
        -:   43:	struct mf_iter it;
        2:   44:	int err = mf_iter_init(cpool, offset, size, &it);
        2:   45:	if(unlikely(err)) return err;
        -:   46:
        7:   47:	while( !mf_iter_empty(&it) ) {
        3:   48:		if(it.ptr) {
        1:   49:			log_write(LOG_DEBUG, "__mf_read: copying from the chunk\n");
        1:   50:			memcpy(buf, it.ptr, it.step_size);
        1:   51:			*read_bytes += it.step_size;
        -:   52:		}
        -:   53:		else {
        2:   54:			log_write(LOG_DEBUG, "__mf_read: reading data explicitly\n");
        2:   55:			ssize_t pread_size = pread(chpool_fd(cpool), buf, it.step_size, it.offset);
        2:   56:			if(pread_size == -1) return errno;
        2:   57:			*read_bytes += pread_size;
        2:   58:			if(pread_size < it.step_size)
    #####:   59:				break;
        -:   60:		}
        3:   61:		buf += it.step_size;
        3:   62:		err = mf_iter_next(&it);
        3:   63:		if(unlikely(err)) return err;
        -:   64:	}
        -:   65:
        2:   66:	return 0;
        -:   67:}
        -:   68:
        1:   69:int __mf_write(mf_handle_t mf, off_t offset, size_t size, ssize_t *written_bytes, const void* buf) {
        1:   70:	chpool_t *cpool = (chpool_t *)mf;
        1:   71:	*written_bytes = 0;
        1:   72:	log_write(LOG_INFO, "__mf_write: start writing to file...\n");
        -:   73:
        -:   74:
        -:   75:	struct mf_iter it;
        1:   76:	int err = mf_iter_init(cpool, offset, size, &it);
        1:   77:	if(unlikely(err)) return err;
        -:   78:
        4:   79:	while( !mf_iter_empty(&it) ) {
        2:   80:		if(it.ptr) {
        1:   81:			log_write(LOG_DEBUG, "__mf_write: copying to the chunk\n");
        1:   82:			memcpy(it.ptr, buf, it.step_size);
        1:   83:			*written_bytes += it.step_size;
        -:   84:		}
        -:   85:		else {
        1:   86:			log_write(LOG_DEBUG, "__mf_write: writing data explicitly\n");
        1:   87:			ssize_t pwrite_size = pwrite(chpool_fd(cpool), buf, it.step_size, it.offset);
        1:   88:			if(pwrite_size == -1) return errno;
        1:   89:			*written_bytes += pwrite_size;
        1:   90:			if(pwrite_size < it.step_size)
    #####:   91:				break;
        -:   92:		}
        2:   93:		buf += it.step_size;
        2:   94:		err = mf_iter_next(&it);
        2:   95:		if(unlikely(err)) return err;
        -:   96:	}
        -:   97:
        1:   98:	return 0;
        -:   99:}
        -:  100:
        2:  101:int __mf_acquire(mf_handle_t mf, off_t offset, size_t size, void** ptr) {
        2:  102:	chpool_t *cpool = (chpool_t *)mf;
        2:  103:	chunk_t *chunk = NULL;
        -:  104:
        2:  105:	int err = chunk_acquire(cpool, offset, size, &chunk);
        2:  106:	if(err) return err;
        -:  107:
        2:  108:	err = chunk_get_mem(chunk, offset, ptr);
        2:  109:	if(unlikely(err)) return err;
        -:  110:
        2:  111:	err = chpool_mem_add(*ptr, chunk);
        2:  112:	return err;
        -:  113:}
        -:  114:
        1:  115:int __mf_release(mf_handle_t mf, size_t dummy, void* ptr) {
        1:  116:	chpool_t *cpool = (chpool_t *)mf;
        1:  117:	chunk_t *chunk = NULL;
        -:  118:
        1:  119:	int err = chpool_mem_get(cpool, ptr, &chunk);
        1:  120:	if(unlikely(err)) return err;
        -:  121:
        1:  122:	err = chunk_release(chunk);
        1:  123:	return err;
        -:  124:}
        -:  125:
        1:  126:int __mf_file_size(mf_handle_t mf, off_t *size) {
        1:  127:	int fd = chpool_fd( (chpool_t *)mf );
        1:  128:	struct stat sb = {0};
        1:  129:	int err = fstat(fd, &sb);
        1:  130:	if(err == -1) return errno;
        1:  131:	*size = sb.st_size;
        1:  132:	return 0;
        -:  133:}
